> 原始 Markdown文档、Visio流程图、XMind思维导图见：https://github.com/LiZhengXiao99/Navigation-Learning

[TOC]

## 一、softGNSS 简介

### 1、概述





卫星信号由导航电文、测距码、载波三个层次组成，





GNSS 原始的信号频率高达 1.5 Ghz，且信号过于微弱，



官网：https://ccar.colorado.edu/gnss/



* **射频前端**：
  * 
* **捕获**：
  * **PRN 码**：卫星由不同的 PRN 码进行区分，通过  ，确定出有哪些卫星。
  * **码相位**：
  * **载波频率**：在下变频的情况下指中频，
* **跟踪**：
  * **码跟踪**：
  * **载波跟踪**：
* **导航电文提取**：
* **观测值提取**：
  * **伪距观测值生成**：
  * **载波相位观测值生成**：
* **定位解算**：







### 2、相关工作

* CSDN 博客：[基于MATLAB编写的GNSS_SDR（GNSS软件接收机）——自学笔记（1）](https://jldxwsj.blog.csdn.net/article/details/116794856)

* 基于 softGNSS 实现的深组合：[kongtian-SiBu / ZCJ_GNSSINS_DeepIntegration](https://github.com/kongtian-SiBu/ZCJ_GNSSINS_DeepIntegration)，作者是空天院的硕士，他还上传了一些他和他同学的一些硕士论文开题报告，相关论文。






### 3、我用 softGNSS 做的事

* 我的本科大创课题是《面向城市复杂环境车载INSGNSS深组合软件接收机研发》

* 基于 softGNSS 学习 GNSS 基带信号处理的原理

* 老师在淘宝上买的射频前端可以采集数据
* 但是买回来的射频前端不好调参数，也没给通信说明，不好自己写采集数据的程序，所以我打算自己实现射频前端。
  





### 4、文件结构







### 5、程序执行流程图

![SoftGNSS流程图](https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/SoftGNSS%E6%B5%81%E7%A8%8B%E5%9B%BE.png)



## 二、程序使用

### 1、射频前端





### 2、参数设置

程序的根目录里：







必须要设置好的配置有：





### 3、处理开源数据









### 4、处理自己采集的数据







### 5、用 Hack RF one 采集数据进行处理

> 暂时还没买 Hack RF，等做成了再更新







## 三、init：程序入口

* `clear; close all; clc;`清理工作空间，关闭打开的窗口。
* format 
  * `'compact'`：这个选项会让MATLAB使用紧凑的格式来显示结果。对于小数，它仅显示足够的小数位以区分不同的实数。例如，1.2和1.200将被显示为相同的输出。
  * `'long'`：这个选项会让MATLAB使用长格式来显示结果。对于小数，它显示所有的有效数字，即使这些数字在末尾是零。例如，1.2和1.200将被显示为不同的输出：1.200和1.2。
  * `'g'`：这是`'general'`的缩写，它让MATLAB选择一种格式，这种格式对于大多数情况都能产生可读的结果。这通常是5位小数，但对于非常大或非常小的数字，小数位数可能会更多或更少。
* addpath 添加 include、geoFunctions 文件夹到工作空间。
* 调用 initSettings() 生成选项结构体 settings。
* 尝试打开设置的文件路径，打开失败输出错误信息，程序终止。
* 打开成功就调用 probeData() 绘制原始 IF 数据的时域采样波、直方图统计、功率谱密度，以对采样数据进行时域和频域分析。
* 





## 四、probeData()：绘制原始数据的时域采样波、直方图、功率谱密度



函数有两种调用方式：

* settings：
* settings和fileName：



### 1、读取数据

* 以二进制只读的方式打开数据文件 fileNameStr，获取文件描述符 fid。
* 根据设置的采样频率 samplesPerCode、采样类型 fileType，读取开头的 100ms 数据，然后关闭文件。
* 判断是否读到 100ms 数据，如果没读取到 100ms 数据，说明文件太短，不进行处理。



### 2、绘时域采样图

* 创建绘图界面，设置时间轴尺度 timeScale，从 0~0.005 





### 3、绘频谱图







### 4、绘制直方图 









## 五、postProcessing：开始后处理

包括解算初始化、信号捕获、通道初始化、信号跟踪、导航定位结算、结果绘制





* **初始化**：打开数据文件，跳过设置的字节数。

  

* **信号捕获**：如果没有设置跳过捕获，就根据设置的采样频率和文件类型读取前 11ms 数据到 data，调用 acquisition() 进行捕获，捕获程序搜索所有可能的 GPS 信号，估计信号频率和C/A码相位，结果保存在结构体 acqResults 中，最后调用 plotAcquisition() 绘制捕获结果。

  

* **通道初始化**：接下来 preRun() 函数读取捕获结果，并初始化所有软件通道。如果卫星数少于通道数，未用的通道被禁用。该程序还负责清空前一次的结果，给本次运行提供新环境。如果没有捕获结果程序就此结束。

  

* **信号跟踪**：通道初始化以后，从记录的文件中读取一组信号采样点送到跟踪模块 track。跟踪模块跟踪所有启用通道中的信号，检测位边界，存储导航数据位并解码。解码之后的卫星星历储存在结构体 eph 中。跟踪结果（相关器、鉴相器等的输出）储存在结构体trackResults中。在 settings 中可设置跟踪数据的长度。

  

* **导航定位解算**：跟踪之后，启动 postNavigaton() 继续对数据进行处理。该函数识别导航电文的子帧头，计算信号传输时间并估算所有的伪距，然后计算天线处的 ECEF 坐标，并转换成指定的坐标系统，如UTM或者WGS84。

  

* **结果绘制**：画出捕获、跟踪和定位结果。













## 六、Acquisition：捕获

### 1、原理

捕获的目的是**确定可见卫星**及卫星信号的**载波频率**、**码相位**的粗略值。

* **可见卫星**：卫星由不同的 PRN 码进行区分，利用 PRN 码良好的自相关性和互相关关性，确定出信号中有对应的 PRN 码，即确定了可见卫星。

* **码相位**：两个伪码只有在时延为零的时候才能得到最大相关值，也就是说，两个信号必须完全对齐才能去除接收信号中的伪码。指的是伪随机码在当前数据块中的时间同步信息。为产生与接收信号伪码相位完全对齐的本地伪码，需要知道码相位，此时则可从信号中去除伪码。

* **载波频率**：在下变频的情况下指的是中频。接收到的 L1 频点 1575.42MHz 射频信号，在下变频器中经过混频后可获得中频信号。但是，接收信号的频率有可能偏离预期值。在视距范围内的卫星速度（相对于接收机）引起的多普勒频移可导致接收信号频率的升高或降低。在最坏的情况下，频差有可能达到 ±10kHz。产生本地载波信号的前提是必须知道接收信号的频率，其目的是用于去除接收信号载波。在通常情况下，搜索得到的最大频率误差为 500Hz 是可以接受的。



信号捕获对应于各个**不同伪码、频率、码相位**的三维搜索单元上通过做码相关运算进行信号搜索，根据相关运算实现方式的不同，信号搜索捕获算法可分为三种：

![三种捕获搜索方式框图](https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/%25E4%25B8%2589%25E7%25A7%258D%25E6%258D%2595%25E8%258E%25B7%25E6%2590%259C%25E7%25B4%25A2%25E6%2596%25B9%25E5%25BC%258F%25E6%25A1%2586%25E5%259B%25BE.png)

* **串行搜索**：输入信号先后与本地产生的 PRN 码、载波相乘，然后进行 1ms 积分之后平方相加；串行搜索算法包括两个不同的扫描过程：

  * 步长 500z、载波频率范围为 IF±10kHz 的频率搜索过程，
  * 遍历 1023 种不同码相位的码相位搜索过程。

  搜索总共需要经过的次数为：
  $$
  \underbrace{1023}_{\text {码相位 }}(\underbrace{2 \frac{10000}{500}+1}_{\text {赖率 }})=1023 \times 41=41943
  $$
  计算分主要有三部分：

  * **PRN 码生成**：采用移位寄存器生成，可以在每次捕获的时候由伪码发生器生成，也可以离线产生；由于要做伪码相移相乘，还要存下伪码所有可能的相位值，也就是要存下 1023 * 32 = 32736 组不同的伪码；为了能使本地的伪码于接收到的信号相乘，本地伪码也要于进行接收信号相同的采样，假设接收的中频信号采样频率为 10 MHz，那对应伪随机序列长度由 1023 变为 10000。
  * **载波相位生成**：
  * **积分于平方**：平方是为了获得信号功率，再做积分将信号所有点的功率相加，如果本地 PRN 码于接收到信号的 PRN 码完全对齐，将达到相关峰值。

  

* **并行频率搜索**：接收信号与对应于某一特定卫星的本地伪码序列相乘，码相位从0~1022。将得到的结果通过傅里叶变换转换为频域信号，

  



* **并行码相位搜索**：





![image-20231202162424616](https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20231202162424616.png)





可以基于不同的标准选择用于捕获的数据长度。第一个需要考虑的因素是导航数据位跳变的影响。前面提到的这些算法均不能忽略捕获过程中出现的位跳变。为了保证捕获算法的最佳性能，必须保证在分析的数据序列中不存在数据跳变。

正如前面所提到的，导航数据传输速率为50b/s,因此每20ms可能出现一次位跳变。假定将10s的数据用于捕获，就有可能出现1次位跳变，且其出现概率几乎可达50%（不是确切的50%，主要是因为两个连续的数据位可能具有相同的数值）。但是，如果捕获是在两个连续的序列中进行的，每个序列的长度均为10ms,则至少一个序列应不包括位跳变。

当选择用于捕获的数据长度时，第二个需要考虑的因素是成功捕获的概率。这个问题可以基于对某一特定卫星而言检测到正确参数的概率与被分析数据长度成正比的原理考虑。

第三个需要考虑的因素是计算量，也是数据长度的函数。此因素实际上与前一个因素是冲突的，序列越长则计算速度越慢。用于捕获的数据长度的选择一定要综合考虑前面所提到的三个因素。如果考虑数据位跳变的影响，则有可能对于每一次捕获均需要运行两次相应的捕获算法。为了保证捕获成功，数据长度不能太短。但是，也不能太长，否则会导致
计算量非常大并且很耗时。

一个折中的办法是用于捕获算法的数据长度为1ms,对应于一个完整的C/A码周期，这样简化了算法，也不需要对伪码进行复制。数据长度不能再短了，否则会导致与不完整伪码的相关。被分析数据可以比1s长些，但是正如前面所提到的，这样会导致计算效率的降低。为了保证在分析的数据序列中发生数据位跳变时仍能实现对某一颗卫星信号的捕获，在第一次捕获未成功的情况下可以进行第二次捕获。





### 2、执行流程



输入参数：

* **longSignal**：
* **settings**：

输出参数：

* **acqResults**：



捕获函数每隔 0.5kHz 搜索一次 GPS 信号，在每个频率搜索阶段，同时搜索码相位。每次搜索之后保存相关结果并进入下一频率单元，由此函数遍历所有的频段（用户定义的多普勒空间），接下来寻找函数最大相关值（相关峰）。之后，寻找同一频率单元中的第二大相关值，然后计算其比值并作为信号检测的规则，该比值用于和接收机中预设的变量值acq_threshold进行比较。
检测器与采样频率无关，因此也与峰值大小及噪声电平无关。

如果第一峰值与第二峰值的比值超过门限值，则利用FFT方法找到精确的载波频率，以协助跟踪环中的PLL启动信号跟踪。0.5kHz的频率精度对于PLL跟踪太粗略了。

输出是数组结构变量acqResult,包含Acq_satelliteList中指定的所有卫星的搜索结果。如果某一颗卫星的信号被检测到，那么对应的signalDetected会被置1。

函数参数为初始的数据记录、预先产生的C/A码表和settings结构体。Settings结构中包含的与捕获有关的变量如下：

* **Acg_satelliteList**：指定一组卫星伪随机序列。捕获只对特定卫星进行。默认状态为空表，启动搜索所有可见卫星1~32.

* **Acq_searchBand**：指定卫星信号搜索的频率范围，为 kHz 的整数倍，并以 F 为中心频率。用于捕获函数的步长为 0.5kHz.

* **Acq_threshold**：信号检测器的门限。

  



* **初始化**：
  * 计算单码片采样点数 samplesPerCode
  * 创建两个 1ms 
  * 计算采样间隔 ts （采样频率的倒数）
  * 查找本地载波的相位点 phasePoints
  * 计算搜索带宽内采样点数 numberOfFrqBins：以中心频率为中心，两边各 acqSearchBand 个点
  * 调用 makeCaTable() 生成所有 C/A 代码到 caCodesTable，并根据采样频率进行采样。





* **做相关运算**：遍历设置的卫星 PRN 列表 acqSatelliteList（默认全部的 32 个 PRN 都搜索）
  * 对 caCodesTable 存的 C/A 码做 fft 并取复共轭存到 caCodeFreqDom
  * for 循环，在搜索带宽内





* **查找结果中的相关峰值**：





* **高分辨率搜索**：







#### 3、makeCaTable()：











## 七、Tracking：跟踪

### 1、原理





输入参数：

* **fid**：
* **channel**：
* **settings**：

输出参数：

* **trackResults**：
* **channel**：





### 2、执行流程

该函数跟踪分配到每一通道中的GPS信号。此函数需要如下参数：从前端获得的一段数据，结构变量Channel，正弦函数，余弦函数和C/A码表。此函数处理采样数据并返回两个结构变量：跟踪结果TrackResults和更新的结构变量Channel.Channel结构变量用来传递每个通道的初始信息并存储当前通道的信息，其另外一个目的是使跟踪具有连贯性。用这种方法，处理两个或者更多的数据段可以连续进行。该结构包含当前(处理上1s数据)的载波频率、码相位、跟踪卫星号、环路滤波器的临时参数和本地信号发生器的信息。

Settings 结构中的载波跟踪参数包括：

* PLL_dampingRatio：阻尼比。
* PLL_noiseBandwidth PLL：噪声带宽。

Settings 结构中的码跟踪相关的参数如下：

* DLL_CACorrelatorSpacing：超前和滞后相关器的间距，单位是码片。
* DLL_damplingRatio DLL：阻尼比。
* DLL_noiseBandwidth DLL：噪声带宽。

trackResults 结构是跟踪函数的主要输出，包含所有通道每Ims的跟踪结果：信号属性信息（载波频率和码相位）和6个相关器及环路鉴别器的输出。跟踪结果将作为函数 postNavigation 的输人，Plottracking 用来绘制每一通道的结果，其余信息用于绘制跟踪结果并分析接收机性能。













## 八、plotNavigation：定位解算





输入参数：

* **trackResults**：
* **settings**：

输出参数：

* **navSolutions**：
* **eph**：





该函数从确定位转变和帧头位置开始，得到每一位的值，并解码获得星历，包括子帧1、子帧2和子帧3。子帧4和子帧5里的信息也可能包括，如图A.4所示。

接下来该函数调用伪距测量函数并计算位置坐标。伪距和位置的计算覆盖接收机settings结构变量中描述的指定时间段





postNavigation函数读取以下变量：

* navSolPeriod：计算伪距和位置的频率。
* elevationMask：卫星屏蔽角，设置用于位置计算的卫星的最小仰角。低仰角卫星信号其大气误差大。
* UTMzone：UTM时区用来转换坐标(ECEF到UTM),这是一个与接收机位置有关的整数。
* truePosition：如果接收机天线的精确位置已知，则可指定天线的（东、北、天）坐标，此坐标从软件接收机计算的结果中提取，并画出其图。也可输人(E、N、U)做为近似坐标或零点。







### 1、calculatePseudoranges()：伪距计算

主要就是计算传播时间 pseudoranges，传播时间乘以光速得到伪距观测值。









### 2、satpos()：卫星位置计算















### 3、leastSquarePos()：最小二乘定位解算



leastSquaresPos函数通过伪距计算接收机位置。如果一颗卫星的完整星历无法得到，那么，该卫星的伪距也无法使用。

在第一次计算时所有卫星的仰角都被设为最大值。因为在一开始，接收机并不知道卫星的仰角，所以使用所有的卫星计算位置，当确定了接收机的位置以后，排除仰角低于elevation_Mask的卫星。

postNavigation函数使用了Easy Suite中几个修改的函数，在postNavigation 函数的最后，ECEF坐标被转化为 UTM 和大地坐标系统，结果保存在 navSolutions 结构变量中。

































